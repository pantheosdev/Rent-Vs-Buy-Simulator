diff --git a/rbv/__main__.py b/rbv/__main__.py
index a521ddc..8e26e44 100644
--- a/rbv/__main__.py
+++ b/rbv/__main__.py
@@ -21,6 +21,7 @@ import argparse
 import json
 import sys
 from pathlib import Path
+import datetime as _dt
 
 # ---------------------------------------------------------------------------
 # Default cfg — matches the engine's expected keys and types
@@ -63,6 +64,15 @@ _DEFAULT_CFG: dict = {
     # Moving costs
     "moving_cost": 2000.0,
     "moving_freq": 5.0,
+
+    # Purchase / closing cost knobs (used by CLI derivations; UI already computes close/mort/pst)
+    "first_time": True,
+    "toronto": False,
+    "transfer_tax_override": 0.0,
+    "purchase_legal_fee": 1800.0,
+    "home_inspection": 500.0,
+    "other_closing_costs": 0.0,
+    "down_payment_source": "Traditional",
 }
 
 _DEFAULT_RUN: dict = {
@@ -80,12 +90,16 @@ _DEFAULT_RUN: dict = {
 
 def _build_example() -> dict:
     """Return a complete example scenario dict (cfg + run parameters merged)."""
+    cfg = _DEFAULT_CFG.copy()
+    # Policy-dependent rules (transfer taxes, insured premium PST) are date-sensitive.
+    # Pin an as-of date into the scenario file so results are auditable/reproducible.
+    cfg.setdefault("asof_date", _dt.date.today().isoformat())
     return {
         "_comment": (
             "RBV CLI scenario file. 'cfg' keys feed the engine directly; "
             "'run' keys are top-level simulation parameters."
         ),
-        "cfg": _DEFAULT_CFG.copy(),
+        "cfg": cfg,
         "run": _DEFAULT_RUN.copy(),
     }
 
@@ -181,12 +195,19 @@ def main(argv: list[str] | None = None) -> int:
     # Import engine (deferred so --example works without heavy deps installed)
     try:
         from rbv.core.engine import run_simulation_core
+        from rbv.core.purchase_derivations import enrich_cfg_with_purchase_derivations
     except ImportError as exc:
         print(f"Error importing engine: {exc}", file=sys.stderr)
         print("Ensure all dependencies are installed: pip install -r requirements.txt", file=sys.stderr)
         return 1
 
-    cfg = scenario["cfg"]
+    # The Streamlit UI pre-computes derived purchase fields and stores them in cfg.
+    # Headless callers often omit them; enrich missing fields to avoid silent mortgage-free runs.
+    try:
+        cfg = enrich_cfg_with_purchase_derivations(scenario["cfg"], strict=True)
+    except ValueError as exc:
+        print(f"Config error: {exc}", file=sys.stderr)
+        return 1
     run = scenario["run"]
 
     print(
@@ -217,12 +238,24 @@ def main(argv: list[str] | None = None) -> int:
         print("Error: simulation returned no data.", file=sys.stderr)
         return 1
 
+    # Engine returns cash-at-closing (down + closing). For CLI reporting, also expose
+    # closing costs excluding down for clarity.
+    try:
+        price_eff = float(cfg.get("price", 0.0) or 0.0)
+        down_eff = float(cfg.get("down", 0.0) or 0.0)
+        down_eff = max(0.0, min(down_eff, price_eff)) if price_eff > 0 else max(0.0, down_eff)
+    except Exception:
+        down_eff = float(cfg.get("down", 0.0) or 0.0)
+    close_only = (float(close_cash) - float(down_eff)) if close_cash is not None else None
+
     pmt_str = f"${monthly_pmt:,.2f}" if monthly_pmt is not None else "n/a"
-    close_str = f"${close_cash:,.2f}" if close_cash is not None else "n/a"
+    close_str = f"${close_only:,.2f}" if close_only is not None else "n/a"
+    cash_str = f"${close_cash:,.2f}" if close_cash is not None else "n/a"
     win_str = f"{win_pct:.1f}%" if win_pct is not None else "n/a"
     print(
         f"Complete. Monthly payment: {pmt_str}  |  "
-        f"Closing costs: {close_str}  |  "
+        f"Closing costs (excl. down): {close_str}  |  "
+        f"Cash at closing (down + closing): {cash_str}  |  "
         f"Buyer wins: {win_str}",
         file=sys.stderr,
     )
@@ -235,7 +268,8 @@ def main(argv: list[str] | None = None) -> int:
         summary = {
             "horizon_years": cfg["years"],
             "monthly_payment": round(monthly_pmt, 2) if monthly_pmt is not None else None,
-            "closing_costs": round(close_cash, 2) if close_cash is not None else None,
+            "closing_costs": round(close_only, 2) if close_only is not None else None,
+            "cash_at_closing": round(close_cash, 2) if close_cash is not None else None,
             "buyer_win_pct": round(win_pct, 2) if win_pct is not None else None,
             "final_buyer_net_worth": round(float(last[buyer_nw_col]), 2) if buyer_nw_col else None,
             "final_renter_net_worth": round(float(last[renter_nw_col]), 2) if renter_nw_col else None,
diff --git a/rbv/core/engine.py b/rbv/core/engine.py
index f431edc..eac0c92 100644
--- a/rbv/core/engine.py
+++ b/rbv/core/engine.py
@@ -1357,6 +1357,118 @@ def run_heatmap_mc_batch(
     pst = _f(cfg.get("pst", 0.0), 0.0)
     nm = max(1, _i(cfg.get("nm", 1), 1))
 
+    # ---------------------------------------------------------------------
+    # Headless safety: derive missing purchase-time fields
+    # ---------------------------------------------------------------------
+    # The Streamlit UI pre-computes and passes derived purchase fields (mort/close/pst).
+    # Headless callers (CLI/tests/integrations) sometimes omit them. If we run with
+    # mort=0 while price>down, the simulation becomes silently mortgage-free.
+    #
+    # Here we derive *at least* the mortgage principal and insurance PST when missing.
+    # We do NOT attempt to fully rebuild transfer-tax/legal/inspection closing costs
+    # in the engine (those are UI/CLI concerns), but if close is missing we at least
+    # include PST/QST on the insured premium so cash-at-closing is not understated.
+    _purchase_autoderived = False
+    _purchase_autoderived_pst = False
+    _purchase_autoderived_premium = 0.0
+    _purchase_autoderived_ltv = 0.0
+
+    try:
+        _loan0 = max(float(price_use) - float(down_use), 0.0)
+        _ltv0 = (_loan0 / float(price_use)) if float(price_use) > 0 else 0.0
+        _purchase_autoderived_ltv = float(_ltv0)
+    except Exception:
+        _loan0 = 0.0
+        _ltv0 = 0.0
+
+    if _loan0 > 0.0 and float(mort) <= 0.0:
+        _warnings.warn(
+            "Engine cfg missing 'mort' (mortgage principal) while price > down. "
+            "Auto-deriving mortgage principal and insured-premium PST for headless callers. "
+            "For full fidelity, supply 'mort', 'close', and 'pst' (as the UI does).",
+            stacklevel=2,
+        )
+
+        # Policy as-of date (mirrors override recompute)
+        _asof_raw0 = cfg.get("asof_date", None)
+        _asof0 = None
+        if _asof_raw0:
+            try:
+                if hasattr(_asof_raw0, "year"):
+                    _asof0 = _asof_raw0
+                else:
+                    import datetime as _dt0
+                    _asof0 = _dt0.date.fromisoformat(str(_asof_raw0)[:10])
+            except Exception:
+                _asof0 = None
+        if _asof0 is None:
+            import datetime as _dt0
+            _asof0 = _dt0.date.today()
+
+        _premium0 = 0.0
+        _pst0 = 0.0
+        _insured_attempt0 = (float(price_use) > 0.0) and (float(_ltv0) > 0.8 + 1e-12)
+        if _insured_attempt0:
+            _price_cap0 = float(insured_mortgage_price_cap(_asof0))
+            _min_down0 = float(min_down_payment_canada(float(price_use), _asof0))
+            _eligible0 = (float(price_use) < float(_price_cap0)) and (float(down_use) + 1e-9 >= float(_min_down0)) and (float(_ltv0) <= 0.95 + 1e-12)
+            if _eligible0:
+                _dp_src0 = str(cfg.get("down_payment_source", "Traditional") or "Traditional")
+                _cmhc_r0 = float(cmhc_premium_rate_from_ltv(float(_ltv0), _dp_src0))
+                _premium0 = float(_loan0) * float(_cmhc_r0)
+                _prov0 = str(cfg.get("province", "") or "").strip()
+                _pst_rate0 = mortgage_default_insurance_sales_tax_rate(_prov0, _asof0)
+                _pst0 = float(_premium0) * float(_pst_rate0)
+            else:
+                _warnings.warn(
+                    "Insured mortgage indicated by LTV>80%, but policy eligibility checks failed "
+                    "(min down / price cap / max LTV). Proceeding without insured premium.",
+                    stacklevel=2,
+                )
+
+        mort = float(_loan0) + float(_premium0)
+        _purchase_autoderived = True
+        _purchase_autoderived_premium = float(_premium0)
+        if float(pst) <= 0.0 and float(_pst0) > 0.0:
+            pst = float(_pst0)
+            _purchase_autoderived_pst = True
+        if float(close) <= 0.0 and float(pst) > 0.0:
+            close = float(pst)
+
+    # If close exists but pst is missing, fill pst for correct close_base recomputes.
+    if float(close) > 0.0 and float(pst) <= 0.0 and float(_ltv0) > 0.8 + 1e-12:
+        try:
+            _asof_raw1 = cfg.get("asof_date", None)
+            _asof1 = None
+            if _asof_raw1:
+                try:
+                    if hasattr(_asof_raw1, "year"):
+                        _asof1 = _asof_raw1
+                    else:
+                        import datetime as _dt1
+                        _asof1 = _dt1.date.fromisoformat(str(_asof_raw1)[:10])
+                except Exception:
+                    _asof1 = None
+            if _asof1 is None:
+                import datetime as _dt1
+                _asof1 = _dt1.date.today()
+
+            _price_cap1 = float(insured_mortgage_price_cap(_asof1))
+            _min_down1 = float(min_down_payment_canada(float(price_use), _asof1))
+            _eligible1 = (float(price_use) < float(_price_cap1)) and (float(down_use) + 1e-9 >= float(_min_down1)) and (float(_ltv0) <= 0.95 + 1e-12)
+            if _eligible1:
+                _dp_src1 = str(cfg.get("down_payment_source", "Traditional") or "Traditional")
+                _cmhc_r1 = float(cmhc_premium_rate_from_ltv(float(_ltv0), _dp_src1))
+                _premium1 = float(_loan0) * float(_cmhc_r1)
+                _prov1 = str(cfg.get("province", "") or "").strip()
+                _pst_rate1 = mortgage_default_insurance_sales_tax_rate(_prov1, _asof1)
+                _pst1 = float(_premium1) * float(_pst_rate1)
+                if _pst1 > 0.0:
+                    pst = float(_pst1)
+                    _purchase_autoderived_pst = True
+        except Exception:
+            pass
+
     # Special assessment (one-time buyer shock)
     special_assessment_amount = _f(cfg.get("special_assessment_amount", 0.0), 0.0)
     special_assessment_month = _i(cfg.get("special_assessment_month", 0), 0)
@@ -2602,6 +2714,12 @@ def run_simulation_core(
         df.attrs["phase_d_fhsa_supplement"] = float(fhsa_supplement)
         df.attrs["phase_d_fhsa_tax_saving"] = float(fhsa_tax_saving)
         df.attrs["phase_d_ird_penalty"] = float(prepayment_penalty_amount)
+
+        # Headless-derived purchase metadata (non-UI callers missing cfg.mort/pst/close)
+        df.attrs["purchase_autoderived"] = bool(_purchase_autoderived)
+        df.attrs["purchase_autoderived_pst"] = bool(_purchase_autoderived_pst)
+        df.attrs["purchase_autoderived_premium"] = float(_purchase_autoderived_premium)
+        df.attrs["purchase_autoderived_ltv"] = float(_purchase_autoderived_ltv)
     except Exception:
         pass
 
diff --git a/rbv/core/purchase_derivations.py b/rbv/core/purchase_derivations.py
new file mode 100644
index 0000000..7a1f571
--- /dev/null
+++ b/rbv/core/purchase_derivations.py
@@ -0,0 +1,237 @@
+"""Purchase-time derivations shared by UI, CLI, and the core engine.
+
+The Streamlit UI pre-computes several *derived* purchase fields and includes them
+in the engine config dict (``cfg``):
+
+  - ``mort``: initial mortgage principal (base loan + insured premium if applicable)
+  - ``pst``: PST/QST on the insured premium (province/date dependent)
+  - ``close``: total closing costs (transfer tax + fees + pst on premium)
+
+Historically, the engine assumed these keys were always present. That assumption
+is true for the UI, but it is **not** true for headless callers (CLI/tests/other
+integrations). This module provides a single, pure helper to derive those fields
+when missing so headless runs match UI economics.
+"""
+
+from __future__ import annotations
+
+import datetime as _dt
+from dataclasses import dataclass
+
+from .mortgage import _annual_nominal_pct_to_monthly_rate
+from .policy_canada import (
+    cmhc_premium_rate_from_ltv,
+    insured_mortgage_price_cap,
+    min_down_payment_canada,
+    mortgage_default_insurance_sales_tax_rate,
+)
+from .taxes import calc_transfer_tax
+
+
+def _f(x, default: float = 0.0) -> float:
+    try:
+        return float(x)
+    except (TypeError, ValueError):
+        return float(default)
+
+
+def _b(x) -> bool:
+    return bool(x)
+
+
+def _parse_asof_date(x) -> _dt.date:
+    """Parse a policy as-of date.
+
+    Accepts:
+      - datetime.date
+      - datetime.datetime
+      - ISO strings (YYYY-MM-DD...)
+      - None -> today
+    """
+    if x is None:
+        return _dt.date.today()
+    if hasattr(x, "date") and hasattr(x, "year") and hasattr(x, "month") and hasattr(x, "day"):
+        # datetime.date or datetime.datetime
+        try:
+            return x if isinstance(x, _dt.date) and not isinstance(x, _dt.datetime) else x.date()
+        except Exception:
+            return _dt.date.today()
+    try:
+        return _dt.date.fromisoformat(str(x)[:10])
+    except Exception:
+        return _dt.date.today()
+
+
+def _mortgage_payment(principal: float, mr: float, n_months: int) -> float:
+    """Fixed monthly payment.
+
+    Matches the engine's behavior for mr≈0 and negative-rate hypotheticals.
+    """
+    p = _f(principal, 0.0)
+    n = max(1, int(n_months or 1))
+    try:
+        r = float(mr)
+    except Exception:
+        r = 0.0
+    r = max(r, -0.999999)
+    if p <= 0.0:
+        return 0.0
+    if abs(r) < 1e-12:
+        return p / float(n)
+    base = 1.0 + r
+    if base <= 0.0:
+        base = 1e-12
+    pow_ = base ** float(n)
+    return p * (r * pow_) / (pow_ - 1.0)
+
+
+@dataclass(frozen=True)
+class DerivedPurchase:
+    """Derived purchase-time fields."""
+
+    mort: float
+    pst: float
+    close: float
+    monthly_payment: float
+    loan: float
+    premium: float
+    ltv: float
+    transfer_tax_total: float
+
+
+def derive_purchase_fields(cfg: dict, *, strict: bool = False) -> DerivedPurchase:
+    """Derive mort/pst/close/monthly_payment from a (possibly incomplete) cfg.
+
+    If ``strict`` is True, raises ValueError for invalid insured-mortgage scenarios
+    (e.g., down below the minimum rule, LTV>95%, insured above the price cap).
+    """
+    price = _f(cfg.get("price", 0.0), 0.0)
+    down = _f(cfg.get("down", 0.0), 0.0)
+    province = str(cfg.get("province", "Ontario") or "Ontario").strip()
+    down_src = str(cfg.get("down_payment_source", "Traditional") or "Traditional")
+    asof = _parse_asof_date(cfg.get("asof_date", None))
+
+    # Transfer tax knobs (UI-compatible)
+    first_time = _b(cfg.get("first_time", True))
+    toronto = _b(cfg.get("toronto", False))
+    override_amt = _f(cfg.get("transfer_tax_override", 0.0), 0.0)
+    assessed_value = cfg.get("assessed_value", None)
+    if assessed_value is not None:
+        assessed_value = _f(assessed_value, price)
+    ns_deed_transfer_rate = cfg.get("ns_deed_transfer_rate", None)
+    if ns_deed_transfer_rate is not None:
+        ns_deed_transfer_rate = _f(ns_deed_transfer_rate, 0.0)
+        # Back-compat: allow percent-points input like 1.5 for 1.5%
+        if ns_deed_transfer_rate > 1.0:
+            ns_deed_transfer_rate = ns_deed_transfer_rate / 100.0
+
+    tt = calc_transfer_tax(
+        province,
+        float(price),
+        bool(first_time),
+        bool(toronto),
+        override_amount=float(override_amt),
+        asof_date=asof,
+        assessed_value=assessed_value,
+        ns_deed_transfer_rate=ns_deed_transfer_rate,
+    )
+    transfer_tax_total = _f(tt.get("total", 0.0), 0.0)
+
+    # Fees (UI-compatible names)
+    lawyer = _f(cfg.get("purchase_legal_fee", cfg.get("lawyer", 1800.0)), 1800.0)
+    insp = _f(cfg.get("home_inspection", 500.0), 500.0)
+    other = _f(cfg.get("other_closing_costs", 0.0), 0.0)
+
+    # Mortgage
+    loan = max(price - down, 0.0)
+    ltv = (loan / price) if price > 0 else 0.0
+    insured_attempt = (price > 0.0) and (ltv > 0.80 + 1e-12)
+
+    premium = 0.0
+    pst = 0.0
+    mort = loan
+
+    if insured_attempt:
+        min_down = float(min_down_payment_canada(float(price), asof))
+        price_cap = float(insured_mortgage_price_cap(asof))
+
+        if down + 1e-9 < min_down:
+            msg = (
+                f"Minimum down payment is about ${min_down:,.0f} for price ${price:,.0f} "
+                f"as of {asof.isoformat()}."
+            )
+            if strict:
+                raise ValueError(msg)
+        if price >= price_cap:
+            msg = (
+                f"Insured mortgages are not available at/above ${price_cap:,.0f} purchase price "
+                f"as of {asof.isoformat()}."
+            )
+            if strict:
+                raise ValueError(msg)
+        if ltv > 0.95 + 1e-12:
+            msg = f"Maximum LTV for insured mortgages is 95% (ltv={ltv:.4f})."
+            if strict:
+                raise ValueError(msg)
+
+        cmhc_eligible = (down + 1e-9 >= min_down) and (price < price_cap) and (ltv <= 0.95 + 1e-12)
+        if cmhc_eligible:
+            cmhc_r = float(cmhc_premium_rate_from_ltv(float(ltv), down_src))
+            premium = loan * cmhc_r
+            pst_rate = float(mortgage_default_insurance_sales_tax_rate(province, asof))
+            pst = premium * pst_rate
+            mort = loan + premium
+
+    close = transfer_tax_total + lawyer + insp + other + pst
+
+    # Payment uses cfg's amortization months (nm) and nominal annual rate in percent.
+    nm = int(max(1, int(cfg.get("nm", 300) or 300)))
+    rate_pct = _f(cfg.get("rate", 0.0), 0.0)
+    canadian = bool(cfg.get("canadian_compounding", True))
+    mr = _annual_nominal_pct_to_monthly_rate(float(rate_pct), bool(canadian))
+    pmt = _mortgage_payment(mort, float(mr), nm)
+
+    return DerivedPurchase(
+        mort=float(mort),
+        pst=float(pst),
+        close=float(close),
+        monthly_payment=float(pmt),
+        loan=float(loan),
+        premium=float(premium),
+        ltv=float(ltv),
+        transfer_tax_total=float(transfer_tax_total),
+    )
+
+
+def enrich_cfg_with_purchase_derivations(cfg: dict, *, strict: bool = False) -> dict:
+    """Return a copy of ``cfg`` enriched with missing purchase-time derived fields.
+
+    Behavior:
+      - Never mutates the caller's dict.
+      - Computes and fills ``mort``/``pst``/``close`` only when missing/zero.
+      - Always ensures ``asof_date`` is present (ISO string) for auditability.
+    """
+    out = dict(cfg or {})
+
+    # Ensure an as-of date exists so policy-dependent fields are reproducible.
+    asof = _parse_asof_date(out.get("asof_date", None))
+    out["asof_date"] = asof.isoformat()
+
+    need_mort = _f(out.get("mort", 0.0), 0.0) <= 0.0
+    need_close = _f(out.get("close", 0.0), 0.0) <= 0.0
+    need_pst = _f(out.get("pst", 0.0), 0.0) <= 0.0
+
+    # Only derive if something material is missing.
+    if not (need_mort or need_close or need_pst):
+        return out
+
+    d = derive_purchase_fields(out, strict=strict)
+
+    if need_mort and d.mort > 0.0:
+        out["mort"] = float(d.mort)
+    if need_pst and d.pst > 0.0:
+        out["pst"] = float(d.pst)
+    if need_close and d.close > 0.0:
+        out["close"] = float(d.close)
+
+    return out
diff --git a/tests/test_cli_pr1.py b/tests/test_cli_pr1.py
new file mode 100644
index 0000000..5ed01f4
--- /dev/null
+++ b/tests/test_cli_pr1.py
@@ -0,0 +1,21 @@
+import json
+
+
+def test_cli_defaults_derive_mortgage_and_closing_costs(capsys):
+    """The CLI default scenario must not silently run mortgage-free."""
+    from rbv import __main__ as cli
+
+    rc = cli.main(["--json"])
+    assert rc == 0
+
+    out = capsys.readouterr().out
+    data = json.loads(out)
+
+    assert data["monthly_payment"] is not None
+    assert data["monthly_payment"] > 0.0
+
+    assert data["closing_costs"] is not None
+    assert data["closing_costs"] > 0.0
+
+    assert data["cash_at_closing"] is not None
+    assert data["cash_at_closing"] > data["closing_costs"]
