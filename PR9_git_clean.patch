diff --git a/app.py b/app.py
index aada3bd..2496932 100644
--- a/app.py
+++ b/app.py
@@ -44,6 +44,12 @@ from rbv.core.policy_canada import (
 from rbv.core.engine import run_simulation_core, run_heatmap_mc_batch
 from rbv.ui.theme import inject_global_css, BUY_COLOR, RENT_COLOR, BG_BLACK, SURFACE_CARD, SURFACE_INPUT, BORDER, TEXT_MUTED
 from rbv.ui.defaults import PRESETS, build_session_defaults
+from rbv.core.scenario_snapshots import (
+    build_scenario_config,
+    build_scenario_snapshot,
+    parse_scenario_payload,
+    scenario_hash_from_state,
+)
 # --- Cross-session caching for simulation runs ---
 # Streamlit reruns the script on every interaction; Monte Carlo runs can be expensive.
 # st.session_state caches are per-user; st.cache_data provides shared caching across sessions.
@@ -109,7 +115,7 @@ def _rbv_install_plotly_template() -> None:
         tmpl = go.layout.Template(
             layout=dict(
                 font=dict(
-                    family='Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif',
+                    family='Manrope, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif',
                     size=12,
                     color='rgba(241,241,243,0.92)'
                 ),
@@ -815,13 +821,32 @@ def _rbv_capture_scenario_state() -> dict:
             state[k] = st.session_state.get(k)
     return state
 
-def _rbv_make_scenario_payload() -> dict:
-    return {
-        "app": "Rent vs Buy Simulator",
-        "version": _rbv_version_line(),
-        "exported_at": datetime.datetime.now().isoformat(timespec="seconds"),
-        "state": _rbv_capture_scenario_state(),
-    }
+def _rbv_make_scenario_config():
+    return build_scenario_config(
+        _rbv_capture_scenario_state(),
+        allowed_keys=_rbv_scenario_allowed_keys(),
+    )
+
+
+def _rbv_make_scenario_payload(*, slot: str = "active", label: str | None = None, extra_meta: dict | None = None) -> dict:
+    snap = build_scenario_snapshot(
+        _rbv_capture_scenario_state(),
+        slot=slot,
+        label=label,
+        app="Rent vs Buy Simulator",
+        version=_rbv_version_line(),
+        meta=(extra_meta or {}),
+        allowed_keys=_rbv_scenario_allowed_keys(),
+    )
+    return snap.to_dict()
+
+
+def _rbv_scenario_hash_short() -> str:
+    try:
+        return _rbv_make_scenario_config().deterministic_hash()[:12]
+    except Exception:
+        return "n/a"
+
 
 def _rbv_apply_scenario_state(state: dict) -> None:
     if not isinstance(state, dict):
@@ -854,6 +879,72 @@ def _rbv_apply_scenario_state(state: dict) -> None:
         pass
 
 
+def _rbv_parse_imported_scenario(obj: dict) -> tuple[dict, dict]:
+    """Parse legacy or PR9 scenario payloads and return (state, meta)."""
+    try:
+        return parse_scenario_payload(obj if isinstance(obj, dict) else {})
+    except Exception:
+        # Back-compat fallback: older exports may be bare state dicts.
+        if isinstance(obj, dict) and isinstance(obj.get("state"), dict):
+            return dict(obj.get("state") or {}), {}
+        return (dict(obj) if isinstance(obj, dict) else {}), {}
+
+
+def _rbv_compare_slot_key(slot: str) -> str:
+    s = str(slot or "A").strip().upper()[:1] or "A"
+    return f"_rbv_compare_snapshot_{s}"
+
+
+def _rbv_save_compare_snapshot(slot: str) -> None:
+    _slot = str(slot or "A").strip().upper()[:1] or "A"
+    _label = f"Scenario {_slot}"
+    _payload = _rbv_make_scenario_payload(
+        slot=_slot,
+        label=_label,
+        extra_meta={
+            "scenario_select": st.session_state.get("scenario_select"),
+            "province": st.session_state.get("province"),
+        },
+    )
+    st.session_state[_rbv_compare_slot_key(_slot)] = _payload
+    _h = str((_payload or {}).get("scenario_hash") or "")[:12]
+    st.session_state["_rbv_loaded_scenario_msg"] = f"Saved current inputs to {_label} ({_h})."
+
+
+def _rbv_load_compare_snapshot(slot: str) -> None:
+    _slot = str(slot or "A").strip().upper()[:1] or "A"
+    _payload = st.session_state.get(_rbv_compare_slot_key(_slot))
+    if not isinstance(_payload, dict):
+        st.session_state["_rbv_loaded_scenario_msg"] = f"Scenario {_slot} slot is empty."
+        return
+    _state, _meta = _rbv_parse_imported_scenario(_payload)
+    _rbv_apply_scenario_state(_state)
+    _h = str((_meta or {}).get("scenario_hash") or (_payload or {}).get("scenario_hash") or "")[:12]
+    st.session_state["_rbv_loaded_scenario_msg"] = f"Loaded Scenario {_slot} ({_h})."
+    st.rerun()
+
+
+def _rbv_clear_compare_snapshot(slot: str) -> None:
+    _slot = str(slot or "A").strip().upper()[:1] or "A"
+    st.session_state.pop(_rbv_compare_slot_key(_slot), None)
+    st.session_state["_rbv_loaded_scenario_msg"] = f"Cleared Scenario {_slot}."
+
+
+def _rbv_compare_slot_summary(slot: str) -> str:
+    _slot = str(slot or "A").strip().upper()[:1] or "A"
+    _payload = st.session_state.get(_rbv_compare_slot_key(_slot))
+    if not isinstance(_payload, dict):
+        return f"{_slot}: empty"
+    _h = str(_payload.get("scenario_hash") or scenario_hash_from_state(_payload.get("state") or {}))[:12]
+    _meta = _payload.get("meta") if isinstance(_payload.get("meta"), dict) else {}
+    _province = _meta.get("province") or ((_payload.get("state") or {}).get("province") if isinstance(_payload.get("state"), dict) else None)
+    _preset = _meta.get("scenario_select") or ((_payload.get("state") or {}).get("scenario_select") if isinstance(_payload.get("state"), dict) else None)
+    _ts = str(_payload.get("exported_at") or "")[:19].replace("T", " ")
+    _bits = [f"{_slot}", str(_preset or "Custom"), str(_province or "-")]
+    if _ts:
+        _bits.append(_ts)
+    _bits.append(_h)
+    return " • ".join(_bits)
 
 
 # --- Shareable scenario URL (compact, bookmarkable) ---
@@ -1253,12 +1344,11 @@ with st.sidebar:
                         _obj = json.loads(_raw.decode("utf-8"))
                     except Exception:
                         _obj = json.loads(_raw)
-                    if isinstance(_obj, dict) and "state" in _obj:
-                        _rbv_apply_scenario_state(_obj.get("state", {}))
-                    elif isinstance(_obj, dict):
-                        _rbv_apply_scenario_state(_obj)
+                    _state, _meta = _rbv_parse_imported_scenario(_obj if isinstance(_obj, dict) else {})
+                    _rbv_apply_scenario_state(_state)
+                    _canon_h = str((_meta or {}).get("scenario_hash") or scenario_hash_from_state(_state, allowed_keys=_rbv_scenario_allowed_keys()))
                     st.session_state["_rbv_loaded_scenario_hash"] = _h
-                    st.session_state["_rbv_loaded_scenario_msg"] = "Scenario loaded."
+                    st.session_state["_rbv_loaded_scenario_msg"] = f"Scenario loaded ({_canon_h[:12]})."
                     st.rerun()
             except Exception:
                 st.session_state["_rbv_loaded_scenario_msg"] = "Failed to load scenario JSON."
@@ -1266,6 +1356,37 @@ with st.sidebar:
         _msg = st.session_state.get("_rbv_loaded_scenario_msg", "")
         if isinstance(_msg, str) and _msg.strip():
             sidebar_hint(_msg)
+
+        # PR9 foundation: local A/B compare snapshots (state + deterministic hash).
+        st.markdown("<div style='height:6px;'></div>", unsafe_allow_html=True)
+        sidebar_label("Scenario Compare slots (A/B)", "Save the current inputs into A/B slots now. PR10 will render deltas side-by-side using these snapshots.")
+        _col_save_a, _col_save_b = st.columns(2)
+        with _col_save_a:
+            if st.button("Save → A", key="rbv_save_ab_a", use_container_width=True):
+                _rbv_save_compare_snapshot("A")
+        with _col_save_b:
+            if st.button("Save → B", key="rbv_save_ab_b", use_container_width=True):
+                _rbv_save_compare_snapshot("B")
+
+        _col_load_a, _col_load_b = st.columns(2)
+        with _col_load_a:
+            if st.button("Load A", key="rbv_load_ab_a", use_container_width=True):
+                _rbv_load_compare_snapshot("A")
+        with _col_load_b:
+            if st.button("Load B", key="rbv_load_ab_b", use_container_width=True):
+                _rbv_load_compare_snapshot("B")
+
+        _col_clr_a, _col_clr_b = st.columns(2)
+        with _col_clr_a:
+            if st.button("Clear A", key="rbv_clear_ab_a", use_container_width=True):
+                _rbv_clear_compare_snapshot("A")
+        with _col_clr_b:
+            if st.button("Clear B", key="rbv_clear_ab_b", use_container_width=True):
+                _rbv_clear_compare_snapshot("B")
+
+        st.caption(f"Active scenario hash: {_rbv_scenario_hash_short()}")
+        st.caption(_rbv_compare_slot_summary("A"))
+        st.caption(_rbv_compare_slot_summary("B"))
     with st.expander("Economic Scenario", expanded=False):
         st.selectbox(
             "Economic Scenario",
@@ -4681,7 +4802,7 @@ if tab == _TAB_NET:
         height=400, 
         margin=dict(l=0,r=0,t=10,b=0), 
         legend=dict(orientation="h", y=1.1, x=0.5, xanchor="center", font=dict(color="#FFFFFF")), 
-        font=dict(family="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)") 
+        font=dict(family="Manrope, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)") 
     )
     # Thinner, faint white cursor
     fig.update_xaxes(
@@ -5407,7 +5528,7 @@ if tab == _TAB_NET:
             paper_bgcolor="rgba(0,0,0,0)",
             plot_bgcolor="rgba(0,0,0,0)",
             margin=dict(l=40, r=20, t=20, b=40),
-            font=dict(color="#E2E8F0", family="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif"),
+            font=dict(color="#E2E8F0", family="Manrope, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif"),
         )
 
         fig_hm.update_xaxes(title="Home Appreciation (%)", showgrid=False, zeroline=False, mirror=True, ticks="outside")
@@ -5552,7 +5673,7 @@ in your portfolio instead of locking it into home equity. This capital opportuni
         height=420,
         margin=dict(l=0, r=0, t=10, b=0),
         legend=dict(orientation="h", y=1.12, x=0.5, xanchor="center", font=dict(color="#FFFFFF")),
-        font=dict(family="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)"),
+        font=dict(family="Manrope, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)"),
     )
     fig_uc_bar.update_xaxes(tickprefix="$", tickformat=",", gridcolor="rgba(255,255,255,0.14)")
     fig_uc_bar.update_yaxes(gridcolor="rgba(255,255,255,0.14)", autorange="reversed")
@@ -5609,7 +5730,7 @@ in your portfolio instead of locking it into home equity. This capital opportuni
         height=330,
         margin=dict(l=0, r=0, t=10, b=0),
         legend=dict(orientation="h", y=1.1, x=0.5, xanchor="center", font=dict(color="#FFFFFF")),
-        font=dict(family="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)"),
+        font=dict(family="Manrope, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)"),
         hovermode="x unified",
     )
     fig_mo_uc.update_yaxes(tickprefix="$", tickformat=",", gridcolor="rgba(255,255,255,0.14)")
@@ -5640,7 +5761,7 @@ in your portfolio instead of locking it into home equity. This capital opportuni
             height=350, 
             margin=dict(l=0,r=0,t=10,b=0), 
             legend=dict(orientation="h", y=1.1, x=0.5, xanchor="center", font=dict(color="#FFFFFF")), 
-            font=dict(family="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)") 
+            font=dict(family="Manrope, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif", color="rgba(241,241,243,0.92)") 
         )
         fig_uc.update_yaxes(tickprefix="$", tickformat=",", gridcolor="rgba(255,255,255,0.14)")
         fig_uc.update_xaxes(gridcolor="rgba(255,255,255,0.14)")
@@ -7341,8 +7462,8 @@ try:
                 lvl = str(item.get("level", "INFO")).upper()
                 title = str(item.get("title", "")).strip()
                 detail = str(item.get("detail", "")).strip()
-                pill_bg = "rgba(47,139,255,0.16)" if lvl == "OK" else ("rgba(204,85,0,0.16)" if lvl == "WARN" else "rgba(255,255,255,0.10)")
-                pill_bd = "rgba(47,139,255,0.35)" if lvl == "OK" else ("rgba(204,85,0,0.35)" if lvl == "WARN" else "rgba(255,255,255,0.18)")
+                pill_bg = _rbv_rgba(BUY_COLOR, 0.16) if lvl == "OK" else (_rbv_rgba(RENT_COLOR, 0.16) if lvl == "WARN" else "rgba(255,255,255,0.10)")
+                pill_bd = _rbv_rgba(BUY_COLOR, 0.35) if lvl == "OK" else (_rbv_rgba(RENT_COLOR, 0.35) if lvl == "WARN" else "rgba(255,255,255,0.18)")
                 pill_tx = BUY_COLOR if lvl == "OK" else (RENT_COLOR if lvl == "WARN" else "#F8FAFC")
                 st.markdown(
                     f"""
diff --git a/rbv/core/scenario_snapshots.py b/rbv/core/scenario_snapshots.py
new file mode 100644
index 0000000..36afcb7
--- /dev/null
+++ b/rbv/core/scenario_snapshots.py
@@ -0,0 +1,234 @@
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+import datetime as _dt
+import hashlib
+import json
+import math
+from typing import Any, Iterable
+
+try:  # optional, keep module usable without numpy at import time
+    import numpy as _np  # type: ignore
+except Exception:  # pragma: no cover
+    _np = None
+
+SCENARIO_CONFIG_SCHEMA = "rbv.scenario_config.v1"
+SCENARIO_SNAPSHOT_SCHEMA = "rbv.scenario_snapshot.v1"
+
+
+def _normalize_float(x: float) -> int | float | None:
+    try:
+        v = float(x)
+    except Exception:
+        return None
+    if not math.isfinite(v):
+        return None
+    # Collapse signed zero and tiny floating noise for stable hashes across reruns/platforms.
+    if abs(v) < 1e-15:
+        v = 0.0
+    # 12 significant digits is plenty for UI/session inputs while remaining deterministic.
+    v = float(f"{v:.12g}")
+    if abs(v - round(v)) <= 1e-12:
+        return int(round(v))
+    return v
+
+
+def canonicalize_jsonish(value: Any) -> Any:
+    """Return a JSON-safe, deterministically ordered representation.
+
+    Used for scenario hashing and snapshot storage. Best-effort normalization only;
+    unknown objects are stringified instead of raising.
+    """
+    if _np is not None:
+        try:
+            if isinstance(value, _np.generic):
+                value = value.item()
+        except Exception:
+            pass
+
+    if value is None or isinstance(value, (str, bool)):
+        return value
+
+    if isinstance(value, int) and not isinstance(value, bool):
+        return int(value)
+
+    if isinstance(value, float):
+        return _normalize_float(value)
+
+    if isinstance(value, (_dt.datetime, _dt.date)):
+        # Datetime gets ISO string; keep offset if present.
+        try:
+            return value.isoformat()
+        except Exception:
+            return str(value)
+
+    if isinstance(value, dict):
+        out: dict[str, Any] = {}
+        for k in sorted(value.keys(), key=lambda x: str(x)):
+            out[str(k)] = canonicalize_jsonish(value[k])
+        return out
+
+    if isinstance(value, (list, tuple)):
+        return [canonicalize_jsonish(v) for v in value]
+
+    if isinstance(value, set):
+        # Sort on canonical JSON to ensure determinism.
+        items = [canonicalize_jsonish(v) for v in value]
+        return sorted(items, key=lambda x: json.dumps(x, sort_keys=True, separators=(",", ":"), ensure_ascii=True))
+
+    # Common duck-types (e.g., pandas Timestamp) often expose isoformat()
+    if hasattr(value, "isoformat"):
+        try:
+            return value.isoformat()
+        except Exception:
+            pass
+
+    try:
+        return json.loads(json.dumps(value))
+    except Exception:
+        return str(value)
+
+
+def _filter_state(state: dict[str, Any] | None, allowed_keys: Iterable[str] | None = None) -> dict[str, Any]:
+    src = dict(state or {})
+    if allowed_keys is None:
+        return src
+    allowed = {str(k) for k in allowed_keys}
+    return {k: v for k, v in src.items() if str(k) in allowed}
+
+
+@dataclass(frozen=True)
+class ScenarioConfig:
+    state: dict[str, Any] = field(default_factory=dict)
+    schema: str = SCENARIO_CONFIG_SCHEMA
+
+    def __post_init__(self) -> None:
+        # Freeze a shallow copy to avoid external mutation changing hashes.
+        object.__setattr__(self, "state", dict(self.state or {}))
+
+    @property
+    def canonical_state(self) -> dict[str, Any]:
+        return canonicalize_jsonish(self.state)
+
+    def canonical_json(self) -> str:
+        return json.dumps(self.canonical_state, sort_keys=True, separators=(",", ":"), ensure_ascii=True)
+
+    def deterministic_hash(self) -> str:
+        return hashlib.sha256(self.canonical_json().encode("utf-8")).hexdigest()
+
+    def to_dict(self) -> dict[str, Any]:
+        state = self.canonical_state
+        return {
+            "schema": self.schema,
+            "state": state,
+            "hash": hashlib.sha256(json.dumps(state, sort_keys=True, separators=(",", ":"), ensure_ascii=True).encode("utf-8")).hexdigest(),
+        }
+
+    @classmethod
+    def from_state(cls, state: dict[str, Any] | None, *, allowed_keys: Iterable[str] | None = None) -> "ScenarioConfig":
+        return cls(state=_filter_state(state, allowed_keys=allowed_keys))
+
+    @classmethod
+    def from_payload(cls, payload: dict[str, Any] | None) -> "ScenarioConfig":
+        obj = dict(payload or {})
+        if isinstance(obj.get("config"), dict):
+            cfg = obj["config"]
+            return cls(state=dict(cfg.get("state") or {}), schema=str(cfg.get("schema") or SCENARIO_CONFIG_SCHEMA))
+        if "state" in obj and isinstance(obj.get("state"), dict):
+            return cls(state=dict(obj.get("state") or {}))
+        # Back-compat: treat bare dict as state
+        return cls(state=obj)
+
+
+@dataclass(frozen=True)
+class ScenarioSnapshot:
+    config: ScenarioConfig
+    slot: str = "active"
+    label: str | None = None
+    app: str = "Rent vs Buy Simulator"
+    version: str | None = None
+    exported_at: str = field(default_factory=lambda: _dt.datetime.now().isoformat(timespec="seconds"))
+    meta: dict[str, Any] = field(default_factory=dict)
+    schema: str = SCENARIO_SNAPSHOT_SCHEMA
+
+    def __post_init__(self) -> None:
+        object.__setattr__(self, "meta", dict(self.meta or {}))
+        object.__setattr__(self, "slot", str(self.slot or "active"))
+
+    @property
+    def scenario_hash(self) -> str:
+        return self.config.deterministic_hash()
+
+    def to_dict(self) -> dict[str, Any]:
+        cfg_dict = self.config.to_dict()
+        return {
+            "schema": self.schema,
+            "app": self.app,
+            "version": self.version,
+            "exported_at": self.exported_at,
+            "slot": self.slot,
+            "label": self.label,
+            "scenario_hash": cfg_dict.get("hash"),
+            "config": cfg_dict,
+            # Back-compat convenience for old importers that only look for `state`
+            "state": cfg_dict.get("state", {}),
+            "meta": canonicalize_jsonish(self.meta),
+        }
+
+    @classmethod
+    def from_payload(cls, payload: dict[str, Any] | None) -> "ScenarioSnapshot":
+        obj = dict(payload or {})
+        cfg = ScenarioConfig.from_payload(obj)
+        return cls(
+            config=cfg,
+            slot=str(obj.get("slot") or "active"),
+            label=(None if obj.get("label") is None else str(obj.get("label"))),
+            app=str(obj.get("app") or "Rent vs Buy Simulator"),
+            version=(None if obj.get("version") is None else str(obj.get("version"))),
+            exported_at=str(obj.get("exported_at") or _dt.datetime.now().isoformat(timespec="seconds")),
+            meta=dict(obj.get("meta") or {}),
+            schema=str(obj.get("schema") or SCENARIO_SNAPSHOT_SCHEMA),
+        )
+
+
+def build_scenario_config(state: dict[str, Any] | None, *, allowed_keys: Iterable[str] | None = None) -> ScenarioConfig:
+    return ScenarioConfig.from_state(state, allowed_keys=allowed_keys)
+
+
+def scenario_hash_from_state(state: dict[str, Any] | None, *, allowed_keys: Iterable[str] | None = None) -> str:
+    return build_scenario_config(state, allowed_keys=allowed_keys).deterministic_hash()
+
+
+def build_scenario_snapshot(
+    state: dict[str, Any] | None,
+    *,
+    slot: str = "active",
+    label: str | None = None,
+    app: str = "Rent vs Buy Simulator",
+    version: str | None = None,
+    meta: dict[str, Any] | None = None,
+    allowed_keys: Iterable[str] | None = None,
+) -> ScenarioSnapshot:
+    return ScenarioSnapshot(
+        config=build_scenario_config(state, allowed_keys=allowed_keys),
+        slot=slot,
+        label=label,
+        app=app,
+        version=version,
+        meta=dict(meta or {}),
+    )
+
+
+def parse_scenario_payload(payload: dict[str, Any] | None) -> tuple[dict[str, Any], dict[str, Any]]:
+    """Return (state, metadata) from legacy or v1 snapshot payloads."""
+    snap = ScenarioSnapshot.from_payload(payload)
+    meta = {
+        "slot": snap.slot,
+        "label": snap.label,
+        "scenario_hash": snap.scenario_hash,
+        "schema": snap.schema,
+        "version": snap.version,
+        "exported_at": snap.exported_at,
+        "app": snap.app,
+    }
+    return dict(snap.config.canonical_state), meta
diff --git a/rbv/qa/qa_truth_tables.py b/rbv/qa/qa_truth_tables.py
index 64f7d32..3762ff9 100644
--- a/rbv/qa/qa_truth_tables.py
+++ b/rbv/qa/qa_truth_tables.py
@@ -770,6 +770,56 @@ def _tt_discount_rate_unit_guard() -> None:
     assert (bpv > 1_000.0) and (rpv > 1_000.0)
 
 
+def _tt_scenario_snapshot_hash_stable_roundtrip() -> None:
+    from rbv.core.scenario_snapshots import (
+        build_scenario_config,
+        build_scenario_snapshot,
+        parse_scenario_payload,
+    )
+
+    state_a = {
+        "price": 800000.0,
+        "down": 160000.00000000003,
+        "province": "Ontario",
+        "years": 25,
+        "use_volatility": False,
+    }
+    # Same semantic values, different key order / floating noise.
+    state_b = {
+        "use_volatility": False,
+        "years": 25.0,
+        "province": "Ontario",
+        "down": 160000.0,
+        "price": 800000,
+    }
+
+    cfg_a = build_scenario_config(state_a)
+    cfg_b = build_scenario_config(state_b)
+    assert cfg_a.deterministic_hash() == cfg_b.deterministic_hash()
+
+    snap = build_scenario_snapshot(state_a, slot="A", label="Scenario A", version="qa")
+    payload = snap.to_dict()
+    state_rt, meta = parse_scenario_payload(payload)
+    assert state_rt.get("province") == "Ontario"
+    assert int(state_rt.get("years")) == 25
+    assert float(state_rt.get("down")) == 160000.0
+    assert str(meta.get("slot")) == "A"
+    assert str(meta.get("scenario_hash")) == cfg_a.deterministic_hash()
+
+
+def _tt_scenario_snapshot_filters_allowed_keys() -> None:
+    from rbv.core.scenario_snapshots import build_scenario_snapshot
+
+    state = {"price": 700000, "province": "Quebec", "_tmp": "ignore-me"}
+    snap = build_scenario_snapshot(state, slot="B", allowed_keys=["price", "province"])
+    payload = snap.to_dict()
+    st = payload.get("state") or {}
+    assert "price" in st and "province" in st
+    assert "_tmp" not in st
+    assert str(payload.get("slot")) == "B"
+    assert bool(payload.get("scenario_hash"))
+
+
 def main(argv: list[str] | None = None) -> None:
     # Mortgage invariants
     _tt_mortgage_rate_and_payment()
@@ -789,6 +839,8 @@ def main(argv: list[str] | None = None) -> None:
     _tt_cg_inclusion_tier_and_shelter()
     _tt_discount_rate_unit_guard()
     _tt_ui_defaults_match_presets()
+    _tt_scenario_snapshot_hash_stable_roundtrip()
+    _tt_scenario_snapshot_filters_allowed_keys()
 
     # Rent control cadence
     _tt_rent_control_cadence_every3()
diff --git a/rbv/ui/theme.py b/rbv/ui/theme.py
index 536ba99..c4a3c84 100644
--- a/rbv/ui/theme.py
+++ b/rbv/ui/theme.py
@@ -1,6 +1,8 @@
+import re
+
 # Minimal UI theme helpers (modular split)
 
-# --- Theme constants (Azure B + warm orange; Phase 3 contrast tune) ---
+# --- Theme constants (premium teal + violet on deep navy surfaces) ---
 BUY_COLOR = "#4FD1C5"
 RENT_COLOR = "#C084FC"
 
@@ -26,7 +28,7 @@ _RBV_GLOBAL_CSS_RAW = r""":root{
 
 /* --- Global typography (Sprint 1) --- */
 html, body, [data-testid="stAppViewContainer"], [data-testid="stSidebar"]{
-  font-family: var(--rbv-font-sans) !important;
+  font-family: var(--rbv-font) !important;
   font-size: 13px !important;
   line-height: 1.35 !important;
   -webkit-font-smoothing: antialiased;
@@ -3536,10 +3538,10 @@ button[data-testid="baseButton-secondary"]:focus-visible{
    Keep this block near the end so it can safely override older legacy rules. */
 
 /* Keep one type system for a cleaner, premium look and less layout shifting. */
-:root{ --rbv-font: var(--rbv-font-sans) !important; }
+:root{ --rbv-font: "Manrope", var(--rbv-font-sans) !important; }
 html, body, .stApp,
 .stApp :is(p, label, input, textarea, button, select, option, h1,h2,h3,h4,h5,h6, th, td, li, a, small, strong, em){
-  font-family: var(--rbv-font-sans) !important;
+  font-family: var(--rbv-font) !important;
 }
 
 /* Improve content readability and information hierarchy. */
@@ -3701,23 +3703,73 @@ html:focus-within{ scroll-behavior: smooth; }
 
 
 
+def _hex_to_rgb(h: str) -> tuple[int, int, int]:
+    h = (h or "").lstrip("#")
+    if len(h) != 6:
+        return (0, 0, 0)
+    try:
+        return (int(h[0:2], 16), int(h[2:4], 16), int(h[4:6], 16))
+    except Exception:
+        return (0, 0, 0)
+
+
+def _dynamic_palette_vars_css(buy_color: str, rent_color: str) -> str:
+    br, bg, bb = _hex_to_rgb(buy_color)
+    rr, rg, rb = _hex_to_rgb(rent_color)
+    return f""":root{{
+  --buy: {buy_color};
+  --rent: {rent_color};
+  --buy-rgb: {br}, {bg}, {bb};
+  --rent-rgb: {rr}, {rg}, {rb};
+  --buy-soft-bg: rgba({br}, {bg}, {bb}, 0.12);
+  --buy-soft-border: rgba({br}, {bg}, {bb}, 0.34);
+  --rent-soft-bg: rgba({rr}, {rg}, {rb}, 0.12);
+  --rent-soft-border: rgba({rr}, {rg}, {rb}, 0.34);
+  --rbv-bg: {BG_BLACK};
+  --rbv-surface: {SURFACE_CARD};
+  --rbv-surface-2: {SURFACE_INPUT};
+  --rbv-border: {BORDER};
+  --rbv-muted: {TEXT_MUTED};
+}}
+
+/* Force key areas to consume the canonical palette variables (wins over older style blocks). */
+.st-key-rbv_tab_nav label:has(input:checked){{
+  background: linear-gradient(180deg, rgba({br}, {bg}, {bb}, 0.20) 0%, rgba({br}, {bg}, {bb}, 0.11) 100%) !important;
+  border-color: rgba({br}, {bg}, {bb}, 0.40) !important;
+}}
+.title-banner{{
+  background:
+    linear-gradient(115deg, rgba({br}, {bg}, {bb}, 0.18) 0%, rgba({rr}, {rg}, {rb}, 0.14) 56%, rgba(255,255,255,0.02) 100%) !important;
+}}
+div[data-baseweb="input"] > div:focus-within,
+div[data-baseweb="select"] > div:focus-within,
+div[data-baseweb="textarea"] > div:focus-within{{
+  border-color: rgba({br}, {bg}, {bb}, 0.75) !important;
+  box-shadow: 0 0 0 3px rgba({br}, {bg}, {bb}, 0.22) !important;
+}}
+"""
+
+
 def _apply_palette(css: str, buy_color: str, rent_color: str) -> str:
     """Replace legacy hard-coded palette values with the current theme palette."""
-    css = css.replace("#2F8BFF", buy_color).replace("#E6B800", rent_color)
-
-    # Also replace common rgba() occurrences for the legacy colors used across charts/borders.
-    def _hex_to_rgb(h: str):
-        h = (h or "").lstrip("#")
-        if len(h) != 6:
-            return (0, 0, 0)
-        return (int(h[0:2], 16), int(h[2:4], 16), int(h[4:6], 16))
+    # Hex replacements (case-insensitive) for historical buy/rent accents.
+    css = re.sub(r"(?i)#2f8bff", buy_color, css)
+    css = re.sub(r"(?i)#3d9bff", buy_color, css)
+    css = re.sub(r"(?i)#e6b800", rent_color, css)
 
     br, bg, bb = _hex_to_rgb(buy_color)
     rr, rg, rb = _hex_to_rgb(rent_color)
 
-    css = css.replace("rgba(47,139,255", f"rgba({br},{bg},{bb}".format(br=br, bg=bg, bb=bb))
-    css = css.replace("rgba(61,155,255", f"rgba({br},{bg},{bb}".format(br=br, bg=bg, bb=bb))
-    css = css.replace("rgba(230,184,0", f"rgba({rr},{rg},{rb}".format(rr=rr, rg=rg, rb=rb))
+    # Harden palette propagation: map both legacy azure rgba families to buy_color, regardless of spacing.
+    css = re.sub(r"rgba\(\s*47\s*,\s*139\s*,\s*255\s*,", f"rgba({br},{bg},{bb},", css, flags=re.IGNORECASE)
+    css = re.sub(r"rgba\(\s*61\s*,\s*155\s*,\s*255\s*,", f"rgba({br},{bg},{bb},", css, flags=re.IGNORECASE)
+    css = re.sub(r"rgb\(\s*47\s*,\s*139\s*,\s*255\s*\)", f"rgb({br},{bg},{bb})", css, flags=re.IGNORECASE)
+    css = re.sub(r"rgb\(\s*61\s*,\s*155\s*,\s*255\s*\)", f"rgb({br},{bg},{bb})", css, flags=re.IGNORECASE)
+
+    # Legacy rent gold.
+    css = re.sub(r"rgba\(\s*230\s*,\s*184\s*,\s*0\s*,", f"rgba({rr},{rg},{rb},", css, flags=re.IGNORECASE)
+    css = re.sub(r"rgb\(\s*230\s*,\s*184\s*,\s*0\s*\)", f"rgb({rr},{rg},{rb})", css, flags=re.IGNORECASE)
+
     return css
 
 
@@ -3734,7 +3786,11 @@ def inject_global_css(st, *, buy_color: str = BUY_COLOR, rent_color: str = RENT_
     harmless and are preferable to intermittent styling loss.
     """
 
-    css = _apply_palette(_RBV_GLOBAL_CSS_RAW + "\n" + _RBV_ACTION_BUTTONS_CSS, buy_color, rent_color)
+    css = _dynamic_palette_vars_css(buy_color, rent_color) + _apply_palette(
+        _RBV_GLOBAL_CSS_RAW + "\n" + _RBV_ACTION_BUTTONS_CSS,
+        buy_color,
+        rent_color,
+    )
 
     st.markdown(
         "<style>\n" + css + "\n</style>",
